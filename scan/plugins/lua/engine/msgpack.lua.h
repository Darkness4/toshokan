#ifndef msgpack_lua_data_H
#define msgpack_lua_data_H

const char msgpack_lua_data[] = \
    "--[[----------------------------------------------------------------------------\n"
    "\n"
    "	MessagePack encoder / decoder written in pure Lua 5.3 / Lua 5.4\n"
    "	written by Sebastian Steinhauer <s.steinhauer@yahoo.de>\n"
    "\n"
    "	This is free and unencumbered software released into the public domain.\n"
    "\n"
    "	Anyone is free to copy, modify, publish, use, compile, sell, or\n"
    "	distribute this software, either in source code form or as a compiled\n"
    "	binary, for any purpose, commercial or non-commercial, and by any\n"
    "	means.\n"
    "\n"
    "	In jurisdictions that recognize copyright laws, the author or authors\n"
    "	of this software dedicate any and all copyright interest in the\n"
    "	software to the public domain. We make this dedication for the benefit\n"
    "	of the public at large and to the detriment of our heirs and\n"
    "	successors. We intend this dedication to be an overt act of\n"
    "	relinquishment in perpetuity of all present and future rights to this\n"
    "	software under copyright law.\n"
    "\n"
    "	THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n"
    "	EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n"
    "	MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\n"
    "	IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR\n"
    "	OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,\n"
    "	ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n"
    "	OTHER DEALINGS IN THE SOFTWARE.\n"
    "\n"
    "	For more information, please refer to <http://unlicense.org/>\n"
    "\n"
    "--]] ----------------------------------------------------------------------------\n"
    "local pack, unpack = string.pack, string.unpack\n"
    "local mtype, utf8len = math.type, utf8.len\n"
    "local tconcat, tunpack = table.concat, table.unpack\n"
    "local ssub = string.sub\n"
    "local type, pcall, pairs, select = type, pcall, pairs, select\n"
    "\n"
    "\n"
    "--[[----------------------------------------------------------------------------\n"
    "\n"
    "		Encoder\n"
    "\n"
    "--]]               ----------------------------------------------------------------------------\n"
    "local encode_value -- forward declaration\n"
    "\n"
    "local function is_an_array(value)\n"
    "  local expected = 1\n"
    "  for k in pairs(value) do\n"
    "    if k ~= expected then\n"
    "      return false\n"
    "    end\n"
    "    expected = expected + 1\n"
    "  end\n"
    "  return true\n"
    "end\n"
    "\n"
    "local encoder_functions = {\n"
    "  ['nil'] = function()\n"
    "    return pack('B', 0xc0)\n"
    "  end,\n"
    "  ['boolean'] = function(value)\n"
    "    if value then\n"
    "      return pack('B', 0xc3)\n"
    "    else\n"
    "      return pack('B', 0xc2)\n"
    "    end\n"
    "  end,\n"
    "  ['number'] = function(value)\n"
    "    if mtype(value) == 'integer' then\n"
    "      if value >= 0 then\n"
    "        if value < 128 then\n"
    "          return pack('B', value)\n"
    "        elseif value <= 0xff then\n"
    "          return pack('BB', 0xcc, value)\n"
    "        elseif value <= 0xffff then\n"
    "          return pack('>BI2', 0xcd, value)\n"
    "        elseif value <= 0xffffffff then\n"
    "          return pack('>BI4', 0xce, value)\n"
    "        else\n"
    "          return pack('>BI8', 0xcf, value)\n"
    "        end\n"
    "      else\n"
    "        if value >= -32 then\n"
    "          return pack('B', 0xe0 + (value + 32))\n"
    "        elseif value >= -128 then\n"
    "          return pack('Bb', 0xd0, value)\n"
    "        elseif value >= -32768 then\n"
    "          return pack('>Bi2', 0xd1, value)\n"
    "        elseif value >= -2147483648 then\n"
    "          return pack('>Bi4', 0xd2, value)\n"
    "        else\n"
    "          return pack('>Bi8', 0xd3, value)\n"
    "        end\n"
    "      end\n"
    "    else\n"
    "      local test = unpack('f', pack('f', value))\n"
    "      if test == value then -- check if we can use float\n"
    "        return pack('>Bf', 0xca, value)\n"
    "      else\n"
    "        return pack('>Bd', 0xcb, value)\n"
    "      end\n"
    "    end\n"
    "  end,\n"
    "  ['string'] = function(value)\n"
    "    local len = #value\n"
    "    if utf8len(value) then -- check if it is a real utf8 string or just byte junk\n"
    "      if len < 32 then\n"
    "        return pack('B', 0xa0 + len) .. value\n"
    "      elseif len < 256 then\n"
    "        return pack('>Bs1', 0xd9, value)\n"
    "      elseif len < 65536 then\n"
    "        return pack('>Bs2', 0xda, value)\n"
    "      else\n"
    "        return pack('>Bs4', 0xdb, value)\n"
    "      end\n"
    "    else -- encode it as byte-junk :)\n"
    "      if len < 256 then\n"
    "        return pack('>Bs1', 0xc4, value)\n"
    "      elseif len < 65536 then\n"
    "        return pack('>Bs2', 0xc5, value)\n"
    "      else\n"
    "        return pack('>Bs4', 0xc6, value)\n"
    "      end\n"
    "    end\n"
    "  end,\n"
    "  ['table'] = function(value)\n"
    "    if is_an_array(value) then -- it seems to be a proper Lua array\n"
    "      local elements = {}\n"
    "      for i, v in pairs(value) do\n"
    "        elements[i] = encode_value(v)\n"
    "      end\n"
    "\n"
    "      local length = #elements\n"
    "      if length < 16 then\n"
    "        return pack('>B', 0x90 + length) .. tconcat(elements)\n"
    "      elseif length < 65536 then\n"
    "        return pack('>BI2', 0xdc, length) .. tconcat(elements)\n"
    "      else\n"
    "        return pack('>BI4', 0xdd, length) .. tconcat(elements)\n"
    "      end\n"
    "    else -- encode as a map\n"
    "      local elements = {}\n"
    "      for k, v in pairs(value) do\n"
    "        elements[#elements + 1] = encode_value(k)\n"
    "        elements[#elements + 1] = encode_value(v)\n"
    "      end\n"
    "\n"
    "      local length = #elements // 2\n"
    "      if length < 16 then\n"
    "        return pack('>B', 0x80 + length) .. tconcat(elements)\n"
    "      elseif length < 65536 then\n"
    "        return pack('>BI2', 0xde, length) .. tconcat(elements)\n"
    "      else\n"
    "        return pack('>BI4', 0xdf, length) .. tconcat(elements)\n"
    "      end\n"
    "    end\n"
    "  end,\n"
    "}\n"
    "\n"
    "encode_value = function(value)\n"
    "  return encoder_functions[type(value)](value)\n"
    "end\n"
    "\n"
    "local function encode(...)\n"
    "  local data = {}\n"
    "  for i = 1, select('#', ...) do\n"
    "    data[#data + 1] = encode_value(select(i, ...))\n"
    "  end\n"
    "  return tconcat(data)\n"
    "end\n"
    "\n"
    "\n"
    "--[[----------------------------------------------------------------------------\n"
    "\n"
    "		Decoder\n"
    "\n"
    "--]]               ----------------------------------------------------------------------------\n"
    "local decode_value -- forward declaration\n"
    "\n"
    "local function decode_array(data, position, length)\n"
    "  local elements, value = {}\n"
    "  for i = 1, length do\n"
    "    value, position = decode_value(data, position)\n"
    "    elements[i] = value\n"
    "  end\n"
    "  return elements, position\n"
    "end\n"
    "\n"
    "local function decode_map(data, position, length)\n"
    "  local elements, key, value = {}\n"
    "  for i = 1, length do\n"
    "    key, position = decode_value(data, position)\n"
    "    value, position = decode_value(data, position)\n"
    "    elements[key] = value\n"
    "  end\n"
    "  return elements, position\n"
    "end\n"
    "\n"
    "local decoder_functions = {\n"
    "  [0xc0] = function(data, position)\n"
    "    return nil, position\n"
    "  end,\n"
    "  [0xc2] = function(data, position)\n"
    "    return false, position\n"
    "  end,\n"
    "  [0xc3] = function(data, position)\n"
    "    return true, position\n"
    "  end,\n"
    "  [0xc4] = function(data, position)\n"
    "    return unpack('>s1', data, position)\n"
    "  end,\n"
    "  [0xc5] = function(data, position)\n"
    "    return unpack('>s2', data, position)\n"
    "  end,\n"
    "  [0xc6] = function(data, position)\n"
    "    return unpack('>s4', data, position)\n"
    "  end,\n"
    "  [0xca] = function(data, position)\n"
    "    return unpack('>f', data, position)\n"
    "  end,\n"
    "  [0xcb] = function(data, position)\n"
    "    return unpack('>d', data, position)\n"
    "  end,\n"
    "  [0xcc] = function(data, position)\n"
    "    return unpack('>B', data, position)\n"
    "  end,\n"
    "  [0xcd] = function(data, position)\n"
    "    return unpack('>I2', data, position)\n"
    "  end,\n"
    "  [0xce] = function(data, position)\n"
    "    return unpack('>I4', data, position)\n"
    "  end,\n"
    "  [0xcf] = function(data, position)\n"
    "    return unpack('>I8', data, position)\n"
    "  end,\n"
    "  [0xd0] = function(data, position)\n"
    "    return unpack('>b', data, position)\n"
    "  end,\n"
    "  [0xd1] = function(data, position)\n"
    "    return unpack('>i2', data, position)\n"
    "  end,\n"
    "  [0xd2] = function(data, position)\n"
    "    return unpack('>i4', data, position)\n"
    "  end,\n"
    "  [0xd3] = function(data, position)\n"
    "    return unpack('>i8', data, position)\n"
    "  end,\n"
    "  [0xd9] = function(data, position)\n"
    "    return unpack('>s1', data, position)\n"
    "  end,\n"
    "  [0xda] = function(data, position)\n"
    "    return unpack('>s2', data, position)\n"
    "  end,\n"
    "  [0xdb] = function(data, position)\n"
    "    return unpack('>s4', data, position)\n"
    "  end,\n"
    "  [0xdc] = function(data, position)\n"
    "    local length\n"
    "    length, position = unpack('>I2', data, position)\n"
    "    return decode_array(data, position, length)\n"
    "  end,\n"
    "  [0xdd] = function(data, position)\n"
    "    local length\n"
    "    length, position = unpack('>I4', data, position)\n"
    "    return decode_array(data, position, length)\n"
    "  end,\n"
    "  [0xde] = function(data, position)\n"
    "    local length\n"
    "    length, position = unpack('>I2', data, position)\n"
    "    return decode_map(data, position, length)\n"
    "  end,\n"
    "  [0xdf] = function(data, position)\n"
    "    local length\n"
    "    length, position = unpack('>I4', data, position)\n"
    "    return decode_map(data, position, length)\n"
    "  end,\n"
    "}\n"
    "\n"
    "-- add fix-array, fix-map, fix-string, fix-int stuff\n"
    "for i = 0x00, 0x7f do\n"
    "  decoder_functions[i] = function(data, position)\n"
    "    return i, position\n"
    "  end\n"
    "end\n"
    "for i = 0x80, 0x8f do\n"
    "  decoder_functions[i] = function(data, position)\n"
    "    return decode_map(data, position, i - 0x80)\n"
    "  end\n"
    "end\n"
    "for i = 0x90, 0x9f do\n"
    "  decoder_functions[i] = function(data, position)\n"
    "    return decode_array(data, position, i - 0x90)\n"
    "  end\n"
    "end\n"
    "for i = 0xa0, 0xbf do\n"
    "  decoder_functions[i] = function(data, position)\n"
    "    local length = i - 0xa0\n"
    "    return ssub(data, position, position + length - 1), position + length\n"
    "  end\n"
    "end\n"
    "for i = 0xe0, 0xff do\n"
    "  decoder_functions[i] = function(data, position)\n"
    "    return -32 + (i - 0xe0), position\n"
    "  end\n"
    "end\n"
    "\n"
    "decode_value = function(data, position)\n"
    "  local byte, value\n"
    "  byte, position = unpack('B', data, position)\n"
    "  value, position = decoder_functions[byte](data, position)\n"
    "  return value, position\n"
    "end\n"
    "\n"
    "\n"
    "--[[----------------------------------------------------------------------------\n"
    "\n"
    "		Interface\n"
    "\n"
    "--]] ----------------------------------------------------------------------------\n"
    "return {\n"
    "  _AUTHOR = 'Sebastian Steinhauer <s.steinhauer@yahoo.de>',\n"
    "  _VERSION = '0.6.1',\n"
    "\n"
    "  -- primary encode function\n"
    "  encode = function(...)\n"
    "    local data, ok = {}\n"
    "    for i = 1, select('#', ...) do\n"
    "      ok, data[i] = pcall(encode_value, select(i, ...))\n"
    "      if not ok then\n"
    "        return nil, 'cannot encode MessagePack'\n"
    "      end\n"
    "    end\n"
    "    return tconcat(data)\n"
    "  end,\n"
    "\n"
    "  -- encode just one value\n"
    "  encode_one = function(value)\n"
    "    local ok, data = pcall(encode_value, value)\n"
    "    if ok then\n"
    "      return data\n"
    "    else\n"
    "      return nil, 'cannot encode MessagePack'\n"
    "    end\n"
    "  end,\n"
    "\n"
    "  -- primary decode function\n"
    "  decode = function(data, position)\n"
    "    local values, value, ok = {}\n"
    "    position = position or 1\n"
    "    while position <= #data do\n"
    "      ok, value, position = pcall(decode_value, data, position)\n"
    "      if ok then\n"
    "        values[#values + 1] = value\n"
    "      else\n"
    "        return nil, 'cannot decode MessagePack'\n"
    "      end\n"
    "    end\n"
    "    return tunpack(values)\n"
    "  end,\n"
    "\n"
    "  -- decode just one value\n"
    "  decode_one = function(data, position)\n"
    "    local value, ok\n"
    "    ok, value, position = pcall(decode_value, data, position or 1)\n"
    "    if ok then\n"
    "      return value, position\n"
    "    else\n"
    "      return nil, 'cannot decode MessagePack'\n"
    "    end\n"
    "  end,\n"
    "}\n"
    "\n"
    "--[[----------------------------------------------------------------------------\n"
    "--]] ----------------------------------------------------------------------------\n"
;

#endif // msgpack_lua_data_H
